import fs from 'fs/promises';
import path from 'path';

export class PlanWriter {
  constructor() {
    this.outputDir = 'plans';
  }

  async writeAllPlans(researchPlan, executionPlan, runPlan, moleculeInfo) {
    await this.ensureOutputDirectory();

    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const moleculeName = this.sanitizeName(moleculeInfo?.name || 'molecule');
    const prefix = `${timestamp}_${moleculeName}`;

    const files = await Promise.all([
      this.writeResearchPlan(researchPlan, `${prefix}_research_plan.md`),
      this.writeExecutionPlan(executionPlan, `${prefix}_execution_plan.md`),
      this.writeRunPlan(runPlan, `${prefix}_run_plan.md`)
    ]);

    return {
      success: true,
      files: files,
      timestamp: timestamp,
      prefix: prefix
    };
  }

  async writeResearchPlan(plan, filename = 'research_plan.md') {
    const markdown = this.generateResearchMarkdown(plan);
    const filePath = path.join(this.outputDir, filename);
    
    await fs.writeFile(filePath, markdown, 'utf8');
    
    return {
      type: 'research_plan',
      filename: filename,
      path: filePath,
      size: markdown.length
    };
  }

  async writeExecutionPlan(plan, filename = 'execution_plan.md') {
    const markdown = this.generateExecutionMarkdown(plan);
    const filePath = path.join(this.outputDir, filename);
    
    await fs.writeFile(filePath, markdown, 'utf8');
    
    return {
      type: 'execution_plan', 
      filename: filename,
      path: filePath,
      size: markdown.length
    };
  }

  async writeRunPlan(plan, filename = 'run_plan.md') {
    const markdown = this.generateRunMarkdown(plan);
    const filePath = path.join(this.outputDir, filename);
    
    await fs.writeFile(filePath, markdown, 'utf8');
    
    // Also write input files if they exist
    if (plan.files) {
      for (const file of plan.files) {
        const inputPath = path.join(this.outputDir, file.name);
        await fs.writeFile(inputPath, file.content, 'utf8');
      }
    }
    
    return {
      type: 'run_plan',
      filename: filename,
      path: filePath,
      size: markdown.length,
      inputFiles: plan.files?.map(f => f.name) || []
    };
  }

  generateResearchMarkdown(plan) {
    return `# Research Plan: ${plan.title}

**Generated by ChemCLI** - ${new Date().toISOString()}

## Overview

**Objective:** ${plan.objective}

**Molecule:** ${plan.molecule}

**Calculation Type:** ${plan.calculationType}

## Theoretical Background

### Method: ${plan.theoreticalBackground.method}

${plan.theoreticalBackground.description}

**Theory:** ${plan.theoreticalBackground.theory}

### References
${plan.theoreticalBackground.references.map(ref => `- ${ref}`).join('\n')}

## Computational Approach

**Functional:** ${plan.computationalApproach.functional}
**Basis Set:** ${plan.computationalApproach.basisSet}
**Software:** ${plan.computationalApproach.software}

### Calculation Steps
${plan.computationalApproach.steps.map((step, i) => 
  `${i + 1}. **${step.name}**: ${step.description}`
).join('\n')}

## Expected Results
${plan.expectedResults.map(result => `- ${result}`).join('\n')}

## Limitations and Considerations
${plan.limitations.map(limitation => `- ${limitation}`).join('\n')}

## Alternative Methods
${plan.alternativeMethods.map(method => `
### ${method.method}
**Description:** ${method.description}

**Advantages:**
${method.advantages ? (Array.isArray(method.advantages) ? method.advantages.map(adv => `- ${adv}`).join('\n') : `- ${method.advantages}`) : '- Not specified'}

**Disadvantages:**
${method.disadvantages ? (Array.isArray(method.disadvantages) ? method.disadvantages.map(dis => `- ${dis}`).join('\n') : `- ${method.disadvantages}`) : '- Not specified'}
`).join('\n')}

---
*This research plan was automatically generated based on the user request and current computational chemistry best practices.*
`;
  }

  generateExecutionMarkdown(plan) {
    return `# Execution Plan: ${plan.title}

**Generated by ChemCLI** - ${new Date().toISOString()}

## Selected Software

**Software:** ${plan.selectedSoftware.name} (${plan.selectedSoftware.version})
**License:** ${plan.selectedSoftware.license}

### Selection Reasons
${plan.selectedSoftware.reasons.map(reason => `- ${reason}`).join('\n')}

### Installation Requirements
- **Required:** ${plan.selectedSoftware.installation.required ? 'Yes' : 'No'}
- **Difficulty:** ${plan.selectedSoftware.installation.difficulty}
- **Command:** \`${plan.selectedSoftware.installation.command}\`

## Computational Setup

| Parameter | Value |
|-----------|-------|
| Method | ${plan.computationalSetup.method} |
| Functional | ${plan.computationalSetup.functional} |
| Basis Set | ${plan.computationalSetup.basisSet} |
| Performance | ${plan.computationalSetup.estimatedPerformance} |
| Parallelization | ${plan.computationalSetup.parallelization ? 'Supported' : 'Not supported'} |

## Resource Requirements

| Resource | Requirement |
|----------|-------------|
| Memory | ${plan.resourceRequirements.memory} |
| CPU Cores | ${plan.resourceRequirements.cpu_cores} |
| Disk Space | ${plan.resourceRequirements.disk_space} |
| Estimated Time | ${plan.resourceRequirements.estimated_time} |

## Alternative Software Options

${plan.alternativeSoftware.map((alt, i) => `
### ${i + 1}. ${alt.name} (Score: ${alt.score})

**Pros:**
${alt.pros.map(pro => `- ${pro}`).join('\n')}

**Cons:**
${alt.cons.map(con => `- ${con}`).join('\n')}

**Why not selected:** ${alt.reason}
`).join('\n')}

## Risk Assessment

${plan.riskAssessment.map(risk => `
### ${risk.risk} (Severity: ${risk.severity})
**Mitigation:** ${risk.mitigation}
`).join('\n')}

## Validation and Benchmarking

**Benchmark Data:** ${plan.validation.benchmarkData}

**Expected Accuracy:** ${plan.validation.expectedAccuracy}

**Comparison Methods:**
${plan.validation.comparisonMethods.map(method => `- ${method}`).join('\n')}

---
*This execution plan provides a detailed roadmap for implementing the computational chemistry calculation.*
`;
  }

  generateRunMarkdown(plan) {
    return `# Run Plan: ${plan.title}

**Generated by ChemCLI** - ${new Date().toISOString()}

## Calculation Summary

| Parameter | Value |
|-----------|-------|
| Software | ${plan.software.toUpperCase()} |
| Calculation Type | ${plan.calculationType} |
| Precision Level | ${plan.precisionLevel} |

## Input Files

${plan.inputFiles.map(file => `
### ${file.name}
**Type:** ${file.type}
**Software:** ${file.software}

\`\`\`
${file.content}
\`\`\`
`).join('\n')}

## Execution Steps

${plan.executionSteps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

## Commands to Run

${plan.commands.map(cmd => `
### ${cmd.step.charAt(0).toUpperCase() + cmd.step.slice(1)}
**Command:** \`${cmd.command}\`
**Description:** ${cmd.description}
${cmd.estimatedTime ? `**Estimated Time:** ${cmd.estimatedTime}` : ''}
${cmd.canFail ? '**Note:** This command may fail - check troubleshooting section if needed.' : ''}
`).join('\n')}

## Job Submission Script

### ${plan.jobScript.name}
${plan.jobScript.description}

\`\`\`bash
${plan.jobScript.content}
\`\`\`

## Expected Output Files

${plan.expectedOutputFiles.map(file => `- ${file}`).join('\n')}

## Post-Processing Steps

${plan.postProcessing.map((step, i) => `${i + 1}. ${step}`).join('\n')}

## Quality Checks

${plan.qualityChecks.map(check => `- [ ] ${check}`).join('\n')}

## Data Extraction

${plan.dataExtraction.map((step, i) => `${i + 1}. ${step}`).join('\n')}

## Troubleshooting

### Common Issues and Solutions

${plan.troubleshooting.map(issue => `- **Issue:** ${issue}`).join('\n')}

### Support Resources
- Check software documentation
- Search online forums and Stack Overflow
- Contact software developers if needed
- Use ChemCLI diagnostic tools

---

## Running the Calculation

1. **Prepare Environment**
   \`\`\`bash
   mkdir -p calculation_${plan.calculationType}
   cd calculation_${plan.calculationType}
   \`\`\`

2. **Copy Input Files**
   Copy the input files generated above to your working directory.

3. **Submit Job**
   \`\`\`bash
   # For local execution
   ${plan.commands.find(cmd => cmd.step === 'calculation')?.command || 'See commands section above'}
   
   # For cluster submission
   sbatch job.sh
   \`\`\`

4. **Monitor Progress**
   \`\`\`bash
   # Check job status
   tail -f ${plan.expectedOutputFiles[0] || 'output.out'}
   \`\`\`

5. **Analyze Results**
   Follow the post-processing and data extraction steps above.

---
*This run plan provides all necessary files and commands to execute the computational chemistry calculation.*
`;
  }

  async ensureOutputDirectory() {
    try {
      await fs.access(this.outputDir);
    } catch {
      await fs.mkdir(this.outputDir, { recursive: true });
    }
  }

  sanitizeName(name) {
    return name.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
  }

  async listPlans() {
    try {
      const files = await fs.readdir(this.outputDir);
      const planFiles = files.filter(file => file.endsWith('.md'));
      
      const plans = [];
      for (const file of planFiles) {
        const filePath = path.join(this.outputDir, file);
        const stats = await fs.stat(filePath);
        plans.push({
          filename: file,
          path: filePath,
          size: stats.size,
          modified: stats.mtime
        });
      }
      
      return plans.sort((a, b) => b.modified - a.modified);
    } catch (error) {
      return [];
    }
  }

  async readPlan(filename) {
    const filePath = path.join(this.outputDir, filename);
    try {
      const content = await fs.readFile(filePath, 'utf8');
      return {
        success: true,
        filename: filename,
        content: content
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
}