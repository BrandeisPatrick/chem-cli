import fs from 'fs/promises';
import path from 'path';

export class RunPlanner {
  constructor() {
    this.inputTemplates = {
      'psi4': {
        'absorption_spectrum': {
          template: `# {title}
memory {memory}
set_num_threads({threads})

molecule {molecule_name} {{
{charge} {multiplicity}
{geometry}
}}

set {{
    reference {reference}
    basis {basis}
}}

# Geometry optimization
optimize('{functional}')

# TD-DFT calculation
energy, wfn = energy('{functional}', return_wfn=True)
res = tdscf(wfn, states={num_states}, triplets='{triplets}')

# Save results
numpy.savetxt('{molecule_name}_excitations.txt', res.da.to_array())
`,
          extensions: ['.in', '.dat'],
          outputFiles: ['output.out', 'excitations.txt', 'geometry.xyz']
        },

        'geometry_optimization': {
          template: `# {title}
memory {memory}
set_num_threads({threads})

molecule {molecule_name} {{
{charge} {multiplicity}
{geometry}
}}

set {{
    reference {reference}
    basis {basis}
    opt_type {opt_type}
}}

optimize('{functional}')
`,
          extensions: ['.in'],
          outputFiles: ['output.out', 'optimized_geometry.xyz']
        }
      },

      'orca': {
        'absorption_spectrum': {
          template: `# {title}
# Generated by ChemCLI

! {functional} {basis} TightSCF
! TDDFT NROOTS {num_states}

%pal nprocs {threads} end
%maxcore {memory_per_core}

* xyz {charge} {multiplicity}
{geometry}
*

%tddft
  nroots {num_states}
  triplets {triplets}
  printlevel 2
end
`,
          extensions: ['.inp'],
          outputFiles: ['output.out', 'molecule.xyz', 'spectrum.dat']
        },

        'geometry_optimization': {
          template: `# {title}
# Generated by ChemCLI

! {functional} {basis} TightSCF Opt

%pal nprocs {threads} end
%maxcore {memory_per_core}

* xyz {charge} {multiplicity}
{geometry}
*
`,
          extensions: ['.inp'],
          outputFiles: ['output.out', 'optimized.xyz']
        }
      },

      'xtb': {
        'geometry_optimization': {
          template: `# Geometry optimization with xTB
# Input coordinates in xyz format
`,
          extensions: ['.xyz'],
          outputFiles: ['xtbopt.xyz', 'xtbopt.log', 'energy']
        }
      }
    };

    this.runCommands = {
      'psi4': {
        'absorption_spectrum': 'psi4 {input_file} {output_file}',
        'geometry_optimization': 'psi4 {input_file} {output_file}'
      },
      'orca': {
        'absorption_spectrum': '{orca_path}/orca {input_file} > {output_file}',
        'geometry_optimization': '{orca_path}/orca {input_file} > {output_file}'
      },
      'xtb': {
        'geometry_optimization': 'xtb {xyz_file} --opt --verbose > {output_file}'
      }
    };
  }

  async plan(executionPlan, moleculeInfo, precisionLevel = 'half') {
    const software = executionPlan.selectedSoftware.name.toLowerCase();
    const calculationType = executionPlan.calculationType;
    const theoryLevel = executionPlan.computationalSetup;

    // Generate input files
    const inputFiles = await this.generateInputFiles(
      software,
      calculationType, 
      theoryLevel,
      moleculeInfo,
      precisionLevel
    );

    // Generate run commands
    const commands = this.generateRunCommands(
      software,
      calculationType,
      inputFiles,
      precisionLevel
    );

    // Generate job script if needed
    const jobScript = this.generateJobScript(
      software,
      calculationType,
      commands,
      executionPlan.resourceRequirements
    );

    const runPlan = {
      title: `Run Plan: ${software.toUpperCase()} ${calculationType}`,
      software: software,
      calculationType: calculationType,
      precisionLevel: precisionLevel,
      
      inputFiles: inputFiles,
      
      executionSteps: this.getExecutionSteps(software, calculationType),
      
      commands: commands,
      
      jobScript: jobScript,
      
      expectedOutputFiles: this.getExpectedOutputFiles(software, calculationType),
      
      postProcessing: this.getPostProcessingSteps(calculationType),
      
      troubleshooting: this.getTroubleshootingGuide(software),
      
      qualityChecks: this.getQualityChecks(calculationType),
      
      dataExtraction: this.getDataExtractionSteps(calculationType, software)
    };

    return {
      success: true,
      runPlan: runPlan,
      files: inputFiles
    };
  }

  async generateInputFiles(software, calculationType, theoryLevel, moleculeInfo, precisionLevel) {
    const template = this.inputTemplates[software]?.[calculationType];
    if (!template) {
      throw new Error(`No template found for ${software} ${calculationType}`);
    }

    const parameters = this.getCalculationParameters(theoryLevel, precisionLevel, moleculeInfo);
    const geometry = this.formatGeometry(moleculeInfo, software);

    const inputContent = this.substituteTemplate(template.template, {
      title: `${calculationType} calculation for ${moleculeInfo.name || 'molecule'}`,
      molecule_name: this.sanitizeMoleculeName(moleculeInfo.name || 'mol'),
      functional: theoryLevel.functional,
      basis: parameters.basis,
      memory: parameters.memory,
      threads: parameters.threads,
      charge: moleculeInfo.charge || 0,
      multiplicity: moleculeInfo.multiplicity || 1,
      geometry: geometry,
      reference: parameters.reference,
      num_states: parameters.numStates,
      triplets: parameters.includeTriplets,
      opt_type: parameters.optType,
      memory_per_core: parameters.memoryPerCore
    });

    const inputFileName = `input${template.extensions[0]}`;
    
    return [{
      name: inputFileName,
      content: inputContent,
      type: 'input',
      software: software
    }];
  }

  getCalculationParameters(theoryLevel, precisionLevel, moleculeInfo) {
    const precisionSettings = {
      'full': {
        basis: theoryLevel.basisSet,
        memory: '16000 MB',
        memoryPerCore: '4000',
        threads: 8,
        numStates: 10,
        includeTriplets: 'true',
        reference: 'rhf',
        optType: 'min'
      },
      'half': {
        basis: this.reduceBasisSet(theoryLevel.basisSet),
        memory: '8000 MB', 
        memoryPerCore: '2000',
        threads: 4,
        numStates: 5,
        includeTriplets: 'false',
        reference: 'rhf',
        optType: 'min'
      },
      'low': {
        basis: 'def2-SVP',
        memory: '4000 MB',
        memoryPerCore: '1000', 
        threads: 2,
        numStates: 3,
        includeTriplets: 'false',
        reference: 'rhf',
        optType: 'min'
      }
    };

    return precisionSettings[precisionLevel] || precisionSettings['half'];
  }

  reduceBasisSet(originalBasis) {
    const reductions = {
      'def2-QZVP': 'def2-TZVP',
      'def2-TZVP': 'def2-SVP',
      'cc-pVTZ': 'cc-pVDZ',
      'aug-cc-pVDZ': 'cc-pVDZ'
    };
    
    return reductions[originalBasis] || 'def2-SVP';
  }

  formatGeometry(moleculeInfo, software) {
    if (!moleculeInfo.atomsString) {
      throw new Error('No geometry information available for molecule');
    }

    // For most software, use XYZ format
    return moleculeInfo.atomsString;
  }

  sanitizeMoleculeName(name) {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
  }

  substituteTemplate(template, variables) {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`\\{${key}\\}`, 'g');
      result = result.replace(regex, value);
    }
    return result;
  }

  generateRunCommands(software, calculationType, inputFiles, precisionLevel) {
    const commandTemplate = this.runCommands[software]?.[calculationType];
    if (!commandTemplate) {
      throw new Error(`No run command found for ${software} ${calculationType}`);
    }

    const inputFile = inputFiles[0].name;
    const outputFile = this.getOutputFileName(inputFile);

    const commands = [];

    // Pre-execution commands
    commands.push({
      step: 'setup',
      command: 'mkdir -p scratch results',
      description: 'Create working directories'
    });

    // Main calculation command
    const mainCommand = commandTemplate
      .replace('{input_file}', inputFile)
      .replace('{output_file}', outputFile)
      .replace('{xyz_file}', inputFile)
      .replace('{orca_path}', process.env.ORCA_PATH || '/opt/orca');

    commands.push({
      step: 'calculation',
      command: mainCommand,
      description: `Run ${software.toUpperCase()} ${calculationType} calculation`,
      estimatedTime: this.getEstimatedTime(calculationType, precisionLevel),
      canFail: true
    });

    // Post-processing commands
    commands.push({
      step: 'cleanup',
      command: 'mv *.out *.log *.xyz results/ 2>/dev/null || true',
      description: 'Move output files to results directory'
    });

    return commands;
  }

  getOutputFileName(inputFile) {
    const baseName = path.parse(inputFile).name;
    return `${baseName}.out`;
  }

  getEstimatedTime(calculationType, precisionLevel) {
    const times = {
      'full': {
        'absorption_spectrum': '4-8 hours',
        'geometry_optimization': '2-4 hours',
        'frequency_analysis': '1-3 hours'
      },
      'half': {
        'absorption_spectrum': '1-2 hours',
        'geometry_optimization': '30-60 minutes', 
        'frequency_analysis': '30-60 minutes'
      },
      'low': {
        'absorption_spectrum': '15-30 minutes',
        'geometry_optimization': '10-20 minutes',
        'frequency_analysis': '10-20 minutes'
      }
    };

    return times[precisionLevel]?.[calculationType] || '30-60 minutes';
  }

  generateJobScript(software, calculationType, commands, resourceRequirements) {
    const scriptTemplate = `#!/bin/bash
#SBATCH --job-name=${calculationType}_${software}
#SBATCH --ntasks=${resourceRequirements.cpu_cores}
#SBATCH --memory=${resourceRequirements.memory}
#SBATCH --time=${this.convertTimeToSlurm(resourceRequirements.estimated_time)}

# Generated by ChemCLI
echo "Starting ${calculationType} calculation using ${software}"
echo "Job started at: $(date)"

# Set environment
export OMP_NUM_THREADS=$SLURM_NTASKS
export MKL_NUM_THREADS=$SLURM_NTASKS

# Run commands
${commands.map(cmd => 
  `echo "${cmd.description}"\n${cmd.command}`
).join('\n\n')}

echo "Job completed at: $(date)"
`;

    return {
      name: 'job.sh',
      content: scriptTemplate,
      type: 'script',
      description: 'SLURM job submission script'
    };
  }

  convertTimeToSlurm(timeStr) {
    // Convert human readable time to SLURM format
    if (timeStr.includes('hour')) {
      const hours = parseInt(timeStr.match(/\d+/)[0]);
      return `${hours}:00:00`;
    }
    if (timeStr.includes('minute')) {
      const minutes = parseInt(timeStr.match(/\d+/)[0]);
      return `0:${minutes}:00`;
    }
    return '2:00:00'; // Default 2 hours
  }

  getExecutionSteps(software, calculationType) {
    const commonSteps = [
      'Prepare working directory',
      'Create input files',
      'Run calculation',
      'Monitor progress',
      'Extract results'
    ];

    const softwareSpecific = {
      'psi4': [
        'Check Psi4 installation',
        'Set environment variables',
        'Run Psi4 calculation',
        'Parse output files'
      ],
      'orca': [
        'Check ORCA installation and license',
        'Set ORCA_PATH environment variable',
        'Run ORCA calculation',
        'Parse ORCA output files'
      ]
    };

    return [...commonSteps, ...(softwareSpecific[software] || [])];
  }

  getExpectedOutputFiles(software, calculationType) {
    const template = this.inputTemplates[software]?.[calculationType];
    return template ? template.outputFiles : ['output.out'];
  }

  getPostProcessingSteps(calculationType) {
    const steps = {
      'absorption_spectrum': [
        'Extract excitation energies and oscillator strengths',
        'Generate UV-Vis spectrum plot',
        'Assign electronic transitions',
        'Calculate spectrum in different units (nm, cm⁻¹, eV)'
      ],
      'geometry_optimization': [
        'Extract optimized geometry',
        'Check convergence criteria',
        'Calculate geometric parameters',
        'Compare with initial structure'
      ],
      'frequency_analysis': [
        'Extract vibrational frequencies',
        'Generate IR spectrum',
        'Calculate thermodynamic properties',
        'Identify imaginary frequencies'
      ]
    };

    return steps[calculationType] || ['Extract basic results'];
  }

  getTroubleshootingGuide(software) {
    const guides = {
      'psi4': [
        'Memory errors: Increase memory allocation',
        'SCF convergence: Try different guess or damping',
        'Geometry optimization fails: Check initial structure'
      ],
      'orca': [
        'License issues: Check ORCA license file',
        'Path errors: Set ORCA_PATH correctly',
        'Memory errors: Adjust %maxcore setting'
      ],
      'xtb': [
        'Convergence issues: Try different optimization algorithm',
        'Large molecules: Consider fragment approach'
      ]
    };

    return guides[software] || ['Check software documentation'];
  }

  getQualityChecks(calculationType) {
    const checks = {
      'absorption_spectrum': [
        'Verify SCF and TD-DFT convergence',
        'Check oscillator strength magnitudes',
        'Compare with experimental spectra if available',
        'Validate excitation character analysis'
      ],
      'geometry_optimization': [
        'Confirm gradient convergence',
        'Check for reasonable bond lengths and angles',
        'Verify no imaginary frequencies (for minima)',
        'Compare energy with initial structure'
      ]
    };

    return checks[calculationType] || ['Verify calculation convergence'];
  }

  getDataExtractionSteps(calculationType, software) {
    const extraction = {
      'absorption_spectrum': {
        'psi4': [
          'Parse excitation energies from output',
          'Extract oscillator strengths',
          'Get transition dipole moments',
          'Extract molecular orbital contributions'
        ],
        'orca': [
          'Parse TDDFT section of output',
          'Extract spectrum data from .out file',
          'Get excited state compositions'
        ]
      },
      'geometry_optimization': {
        'common': [
          'Extract final coordinates',
          'Get final energy',
          'Check optimization status',
          'Extract geometric parameters'
        ]
      }
    };

    return extraction[calculationType]?.[software] || 
           extraction[calculationType]?.['common'] ||
           ['Extract basic results from output files'];
  }
}