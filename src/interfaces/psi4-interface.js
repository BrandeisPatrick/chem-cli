import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

export class Psi4Interface {
  constructor() {
    this.executable = 'psi4';
    this.supportedMethods = {
      'geometry_optimization': ['HF', 'B3LYP', 'CAM-B3LYP', 'M06-2X', 'MP2'],
      'absorption_spectrum': ['B3LYP', 'CAM-B3LYP', 'M06-2X'],
      'frequency_analysis': ['HF', 'B3LYP', 'CAM-B3LYP', 'MP2'],
      'single_point': ['HF', 'B3LYP', 'CAM-B3LYP', 'M06-2X', 'MP2', 'CCSD', 'CCSD(T)'],
      'nmr_prediction': ['B3LYP', 'CAM-B3LYP']
    };
    this.workingDir = 'psi4_calculations';
  }

  async checkInstallation() {
    try {
      const { stdout } = await execAsync(`${this.executable} --version`, { timeout: 10000 });
      const version = stdout.trim().split('\n')[0];
      return {
        installed: true,
        version: version,
        executable: this.executable
      };
    } catch (error) {
      return {
        installed: false,
        error: error.message,
        suggestion: 'Install Psi4 using: conda install -c conda-forge psi4'
      };
    }
  }

  async runCalculation(calculationType, inputData, options = {}) {
    // Ensure working directory exists
    await fs.mkdir(this.workingDir, { recursive: true });
    
    // Generate input file
    const inputFile = await this.generateInputFile(calculationType, inputData, options);
    
    // Run calculation
    const result = await this.executeCalculation(inputFile, options);
    
    // Parse results
    const parsedResults = await this.parseOutput(result.outputFile, calculationType);
    
    return {
      success: result.success,
      inputFile: inputFile,
      outputFile: result.outputFile,
      results: parsedResults,
      executionTime: result.executionTime,
      errors: result.errors
    };
  }

  async generateInputFile(calculationType, inputData, options) {
    const {
      molecule,
      method = 'B3LYP',
      basisSet = 'def2-SVP',
      charge = 0,
      multiplicity = 1,
      memory = '8 GB',
      threads = 4
    } = inputData;

    let inputContent = '';
    
    // Common header
    inputContent += `# ${calculationType} calculation generated by ChemCLI\n`;
    inputContent += `memory ${memory}\n`;
    inputContent += `set_num_threads(${threads})\n\n`;

    // Molecule specification
    inputContent += `molecule {\n`;
    inputContent += `${charge} ${multiplicity}\n`;
    inputContent += `${molecule.atomsString}\n`;
    inputContent += `}\n\n`;

    // Method settings
    inputContent += `set {\n`;
    inputContent += `  reference rhf\n`;
    inputContent += `  basis ${basisSet}\n`;
    if (options.convergence) {
      inputContent += `  e_convergence ${options.convergence.energy}\n`;
      inputContent += `  d_convergence ${options.convergence.density}\n`;
    }
    inputContent += `}\n\n`;

    // Calculation-specific commands
    switch (calculationType) {
      case 'geometry_optimization':
        inputContent += `optimize('${method.toLowerCase()}')\n`;
        break;

      case 'absorption_spectrum':
        inputContent += `# Geometry optimization first\n`;
        inputContent += `optimize('${method.toLowerCase()}')\n\n`;
        inputContent += `# TD-DFT calculation\n`;
        inputContent += `energy, wfn = energy('${method.toLowerCase()}', return_wfn=True)\n`;
        const nStates = options.nStates || 10;
        inputContent += `res = tdscf(wfn, states=${nStates})\n`;
        break;

      case 'frequency_analysis':
        inputContent += `# Optimize first if not already optimized\n`;
        inputContent += `optimize('${method.toLowerCase()}')\n\n`;
        inputContent += `# Frequency calculation\n`;
        inputContent += `freq, wfn = freq('${method.toLowerCase()}', return_wfn=True)\n`;
        break;

      case 'single_point':
        inputContent += `energy('${method.toLowerCase()}')\n`;
        break;

      case 'nmr_prediction':
        inputContent += `# Optimize geometry first\n`;
        inputContent += `optimize('${method.toLowerCase()}')\n\n`;
        inputContent += `# NMR calculation with GIAO\n`;
        inputContent += `set {\n`;
        inputContent += `  gauge origin\n`;
        inputContent += `}\n`;
        inputContent += `property('${method.toLowerCase()}', properties=['shielding'])\n`;
        break;

      default:
        throw new Error(`Unsupported calculation type: ${calculationType}`);
    }

    // Write input file
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `${calculationType}_${timestamp}.in`;
    const filepath = path.join(this.workingDir, filename);
    
    await fs.writeFile(filepath, inputContent);
    
    return {
      filename: filename,
      filepath: filepath,
      content: inputContent
    };
  }

  async executeCalculation(inputFile, options = {}) {
    const startTime = Date.now();
    const outputFile = inputFile.filepath.replace('.in', '.out');
    
    try {
      const command = `cd ${this.workingDir} && ${this.executable} ${inputFile.filename} ${path.basename(outputFile)}`;
      const { stdout, stderr } = await execAsync(command, {
        timeout: options.timeout || 3600000, // 1 hour default
        maxBuffer: 50 * 1024 * 1024 // 50MB buffer
      });

      const executionTime = Date.now() - startTime;

      return {
        success: true,
        outputFile: outputFile,
        stdout: stdout,
        stderr: stderr,
        executionTime: executionTime,
        errors: []
      };

    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      return {
        success: false,
        outputFile: outputFile,
        stdout: error.stdout || '',
        stderr: error.stderr || '',
        executionTime: executionTime,
        errors: [error.message]
      };
    }
  }

  async parseOutput(outputFile, calculationType) {
    try {
      const output = await fs.readFile(outputFile, 'utf8');
      
      switch (calculationType) {
        case 'geometry_optimization':
          return this.parseOptimizationOutput(output);
        case 'absorption_spectrum':
          return this.parseAbsorptionOutput(output);
        case 'frequency_analysis':
          return this.parseFrequencyOutput(output);
        case 'single_point':
          return this.parseSinglePointOutput(output);
        case 'nmr_prediction':
          return this.parseNMROutput(output);
        default:
          return this.parseGenericOutput(output);
      }
    } catch (error) {
      return {
        error: `Failed to parse output: ${error.message}`,
        rawOutput: outputFile
      };
    }
  }

  parseOptimizationOutput(output) {
    const results = {
      converged: false,
      finalEnergy: null,
      optimizedGeometry: null,
      iterations: null,
      gradientNorm: null
    };

    // Check convergence
    if (output.includes('Optimization Converged')) {
      results.converged = true;
    }

    // Extract final energy
    const energyMatch = output.match(/Final energy is\s+(-?\d+\.\d+)/);
    if (energyMatch) {
      results.finalEnergy = parseFloat(energyMatch[1]);
    }

    // Extract number of iterations
    const iterMatch = output.match(/Optimization completed in (\d+) iterations/);
    if (iterMatch) {
      results.iterations = parseInt(iterMatch[1]);
    }

    // Extract optimized geometry (simplified)
    const geomMatch = output.match(/Final optimized geometry and variables:[\s\S]*?(?=\n\s*\n)/);
    if (geomMatch) {
      results.optimizedGeometry = geomMatch[0];
    }

    return results;
  }

  parseAbsorptionOutput(output) {
    const results = {
      excitationEnergies: [],
      oscillatorStrengths: [],
      transitionDipoles: [],
      spectrum: null
    };

    // Parse excitation data
    const tdSection = output.match(/Excited State.*?(?=\n\s*\n)/gs);
    if (tdSection) {
      for (const section of tdSection) {
        const stateMatch = section.match(/Excited State\s+(\d+):\s+(.*?)\s+([\d.]+)\s+eV.*?f=([\d.]+)/s);
        if (stateMatch) {
          results.excitationEnergies.push({
            state: parseInt(stateMatch[1]),
            symmetry: stateMatch[2].trim(),
            energy_eV: parseFloat(stateMatch[3]),
            energy_nm: 1240 / parseFloat(stateMatch[3]), // Convert eV to nm
            oscillatorStrength: parseFloat(stateMatch[4])
          });
        }
      }
    }

    return results;
  }

  parseFrequencyOutput(output) {
    const results = {
      frequencies: [],
      intensities: [],
      thermochemistry: {},
      zeroPointEnergy: null
    };

    // Parse frequencies
    const freqSection = output.match(/Harmonic frequencies[\s\S]*?(?=\n\s*\n)/);
    if (freqSection) {
      const freqMatches = freqSection[0].match(/(\d+\.\d+)\s+cm\*\*-1/g);
      if (freqMatches) {
        results.frequencies = freqMatches.map(match => 
          parseFloat(match.match(/([\d.]+)/)[1])
        );
      }
    }

    // Parse zero-point energy
    const zpeMatch = output.match(/Zero-point correction=\s+([\d.]+)/);
    if (zpeMatch) {
      results.zeroPointEnergy = parseFloat(zpeMatch[1]);
    }

    // Parse thermochemistry
    const thermoMatch = output.match(/Temperature\s+([\d.]+)\s+Kelvin.*?Pressure\s+([\d.]+)\s+Atm/s);
    if (thermoMatch) {
      results.thermochemistry.temperature = parseFloat(thermoMatch[1]);
      results.thermochemistry.pressure = parseFloat(thermoMatch[2]);
    }

    return results;
  }

  parseSinglePointOutput(output) {
    const results = {
      energy: null,
      homoEnergy: null,
      lumoEnergy: null,
      homoLumoGap: null
    };

    // Extract total energy
    const energyMatch = output.match(/Total Energy\s+=\s+(-?\d+\.\d+)/);
    if (energyMatch) {
      results.energy = parseFloat(energyMatch[1]);
    }

    // Extract HOMO/LUMO energies
    const homoMatch = output.match(/HOMO.*?(-?\d+\.\d+)/);
    const lumoMatch = output.match(/LUMO.*?(-?\d+\.\d+)/);
    
    if (homoMatch) results.homoEnergy = parseFloat(homoMatch[1]);
    if (lumoMatch) results.lumoEnergy = parseFloat(lumoMatch[1]);
    
    if (results.homoEnergy !== null && results.lumoEnergy !== null) {
      results.homoLumoGap = results.lumoEnergy - results.homoEnergy;
    }

    return results;
  }

  parseNMROutput(output) {
    const results = {
      shieldings: [],
      chemicalShifts: []
    };

    // Parse NMR shielding constants
    const nmrSection = output.match(/Nuclear Magnetic Shielding[\s\S]*?(?=\n\s*\n)/);
    if (nmrSection) {
      const shieldingMatches = nmrSection[0].match(/(\w+)\s+\d+\s+([\d.-]+)\s+([\d.-]+)\s+([\d.-]+)/g);
      if (shieldingMatches) {
        for (const match of shieldingMatches) {
          const parts = match.trim().split(/\s+/);
          results.shieldings.push({
            atom: parts[0],
            atomNumber: parseInt(parts[1]),
            isotropic: parseFloat(parts[2])
          });
        }
      }
    }

    return results;
  }

  parseGenericOutput(output) {
    return {
      completed: output.includes('Psi4 exiting successfully'),
      rawOutput: output.substring(0, 1000) + (output.length > 1000 ? '...' : '')
    };
  }

  async validateInput(calculationType, inputData) {
    const errors = [];
    
    // Check if method is supported
    const supportedMethods = this.supportedMethods[calculationType];
    if (!supportedMethods || !supportedMethods.includes(inputData.method)) {
      errors.push(`Method ${inputData.method} not supported for ${calculationType}`);
    }

    // Check molecule data
    if (!inputData.molecule || !inputData.molecule.atomsString) {
      errors.push('Molecule geometry is required');
    }

    // Check basis set format
    if (inputData.basisSet && !inputData.basisSet.match(/^[a-zA-Z0-9-]+$/)) {
      errors.push('Invalid basis set format');
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  getSupportedMethods(calculationType) {
    return this.supportedMethods[calculationType] || [];
  }

  getRecommendedSettings(calculationType, moleculeSize) {
    const recommendations = {
      'geometry_optimization': {
        small: { method: 'B3LYP', basisSet: 'def2-TZVP', memory: '4 GB' },
        medium: { method: 'B3LYP', basisSet: 'def2-SVP', memory: '8 GB' },
        large: { method: 'B3LYP', basisSet: 'def2-SVP', memory: '16 GB' }
      },
      'absorption_spectrum': {
        small: { method: 'CAM-B3LYP', basisSet: 'def2-TZVP', memory: '8 GB' },
        medium: { method: 'CAM-B3LYP', basisSet: 'def2-SVP', memory: '16 GB' },
        large: { method: 'B3LYP', basisSet: 'def2-SVP', memory: '32 GB' }
      }
    };

    const sizeCategory = moleculeSize < 15 ? 'small' : 
                        moleculeSize < 50 ? 'medium' : 'large';
    
    return recommendations[calculationType]?.[sizeCategory] || 
           recommendations['geometry_optimization']['medium'];
  }
}