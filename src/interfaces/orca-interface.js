import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

export class ORCAInterface {
  constructor() {
    this.executable = process.env.ORCA_PATH ? path.join(process.env.ORCA_PATH, 'orca') : 'orca';
    this.supportedMethods = {
      'geometry_optimization': ['HF', 'B3LYP', 'CAM-B3LYP', 'M06-2X', 'PBE0', 'MP2', 'CCSD', 'CCSD(T)'],
      'absorption_spectrum': ['B3LYP', 'CAM-B3LYP', 'M06-2X', 'PBE0', 'wB97X-D3'],
      'frequency_analysis': ['HF', 'B3LYP', 'CAM-B3LYP', 'M06-2X', 'PBE0', 'MP2'],
      'single_point': ['HF', 'B3LYP', 'CAM-B3LYP', 'M06-2X', 'MP2', 'CCSD', 'CCSD(T)', 'CASSCF'],
      'nmr_prediction': ['B3LYP', 'CAM-B3LYP', 'PBE0'],
      'reaction_energy': ['B3LYP', 'M06-2X', 'CCSD(T)', 'DLPNO-CCSD(T)']
    };
    this.workingDir = 'orca_calculations';
  }

  async checkInstallation() {
    try {
      // Check if ORCA executable exists
      const { stdout } = await execAsync(`${this.executable} | head -10`, { timeout: 5000 });
      
      // ORCA prints version info to stderr and exits with non-zero status when run without input
      // So we check if the executable can be found and shows ORCA header
      if (stdout.includes('ORCA') || stdout.includes('program system')) {
        return {
          installed: true,
          version: 'ORCA detected',
          executable: this.executable,
          path: process.env.ORCA_PATH || 'System PATH'
        };
      } else {
        throw new Error('ORCA executable found but unexpected output');
      }
    } catch (error) {
      // Try alternative check
      try {
        await execAsync(`which ${this.executable}`, { timeout: 5000 });
        return {
          installed: true,
          version: 'ORCA found in PATH',
          executable: this.executable,
          note: 'Could not determine version'
        };
      } catch (whichError) {
        return {
          installed: false,
          error: error.message,
          suggestion: 'Install ORCA and set ORCA_PATH environment variable',
          downloadUrl: 'https://orcaforum.kofo.mpg.de'
        };
      }
    }
  }

  async runCalculation(calculationType, inputData, options = {}) {
    // Ensure working directory exists
    await fs.mkdir(this.workingDir, { recursive: true });
    
    // Generate input file
    const inputFile = await this.generateInputFile(calculationType, inputData, options);
    
    // Run calculation
    const result = await this.executeCalculation(inputFile, options);
    
    // Parse results
    const parsedResults = await this.parseOutput(result.outputFile, calculationType);
    
    return {
      success: result.success,
      inputFile: inputFile,
      outputFile: result.outputFile,
      results: parsedResults,
      executionTime: result.executionTime,
      errors: result.errors
    };
  }

  async generateInputFile(calculationType, inputData, options) {
    const {
      molecule,
      method = 'B3LYP',
      basisSet = 'def2-SVP',
      charge = 0,
      multiplicity = 1,
      memory = 8000, // MB
      threads = 4
    } = inputData;

    let inputContent = '';
    
    // Common header and job control
    inputContent += `# ${calculationType} calculation generated by ChemCLI\n\n`;
    
    // Job type and method specification
    let jobLine = `! ${method} ${basisSet} TightSCF`;
    
    switch (calculationType) {
      case 'geometry_optimization':
        jobLine += ` Opt`;
        break;
        
      case 'absorption_spectrum':
        jobLine += ` TDDFT`;
        const nRoots = options.nStates || 10;
        inputContent += `! NROOTS ${nRoots}\n`;
        break;
        
      case 'frequency_analysis':
        jobLine += ` Opt Freq`;
        break;
        
      case 'single_point':
        // Single point - no additional keywords needed
        break;
        
      case 'nmr_prediction':
        jobLine += ` NMR`;
        break;
        
      case 'reaction_energy':
        jobLine += ` Opt`;
        break;
    }
    
    inputContent += jobLine + '\n\n';

    // Parallel execution settings
    inputContent += `%pal nprocs ${threads} end\n\n`;
    
    // Memory settings
    const memoryPerCore = Math.floor(memory / threads);
    inputContent += `%maxcore ${memoryPerCore}\n\n`;

    // Method-specific settings
    if (calculationType === 'absorption_spectrum') {
      inputContent += `%tddft\n`;
      inputContent += `  nroots ${options.nStates || 10}\n`;
      if (options.includeTriplets) {
        inputContent += `  triplets true\n`;
      }
      inputContent += `  printlevel 2\n`;
      inputContent += `end\n\n`;
    }

    if (calculationType === 'nmr_prediction') {
      inputContent += `%eprnmr\n`;
      inputContent += `  nuclei = all H { aiso, adip, fgrad }\n`;
      inputContent += `  nuclei = all C { aiso, adip, fgrad }\n`;
      inputContent += `  printlevel 2\n`;
      inputContent += `end\n\n`;
    }

    // SCF convergence settings for difficult cases
    if (options.convergence === 'tight' || molecule.estimatedSize > 50) {
      inputContent += `%scf\n`;
      inputContent += `  maxiter 500\n`;
      inputContent += `  convergence tight\n`;
      inputContent += `end\n\n`;
    }

    // Geometry specification
    inputContent += `* xyz ${charge} ${multiplicity}\n`;
    inputContent += `${molecule.atomsString}\n`;
    inputContent += `*\n`;

    // Write input file
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `${calculationType}_${timestamp}.inp`;
    const filepath = path.join(this.workingDir, filename);
    
    await fs.writeFile(filepath, inputContent);
    
    return {
      filename: filename,
      filepath: filepath,
      content: inputContent
    };
  }

  async executeCalculation(inputFile, options = {}) {
    const startTime = Date.now();
    const outputFile = inputFile.filepath.replace('.inp', '.out');
    
    try {
      // ORCA command
      const command = `cd ${this.workingDir} && ${this.executable} ${inputFile.filename} > ${path.basename(outputFile)} 2>&1`;
      
      const { stdout, stderr } = await execAsync(command, {
        timeout: options.timeout || 7200000, // 2 hour default (ORCA can be slow)
        maxBuffer: 100 * 1024 * 1024 // 100MB buffer
      });

      const executionTime = Date.now() - startTime;

      // Check if calculation completed successfully
      const output = await fs.readFile(outputFile, 'utf8').catch(() => '');
      const success = output.includes('ORCA TERMINATED NORMALLY');

      return {
        success: success,
        outputFile: outputFile,
        stdout: stdout,
        stderr: stderr,
        executionTime: executionTime,
        errors: success ? [] : ['Calculation did not complete successfully']
      };

    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      return {
        success: false,
        outputFile: outputFile,
        stdout: error.stdout || '',
        stderr: error.stderr || '',
        executionTime: executionTime,
        errors: [error.message]
      };
    }
  }

  async parseOutput(outputFile, calculationType) {
    try {
      const output = await fs.readFile(outputFile, 'utf8');
      
      switch (calculationType) {
        case 'geometry_optimization':
          return this.parseOptimizationOutput(output);
        case 'absorption_spectrum':
          return this.parseAbsorptionOutput(output);
        case 'frequency_analysis':
          return this.parseFrequencyOutput(output);
        case 'single_point':
          return this.parseSinglePointOutput(output);
        case 'nmr_prediction':
          return this.parseNMROutput(output);
        case 'reaction_energy':
          return this.parseReactionEnergyOutput(output);
        default:
          return this.parseGenericOutput(output);
      }
    } catch (error) {
      return {
        error: `Failed to parse output: ${error.message}`,
        rawOutput: outputFile
      };
    }
  }

  parseOptimizationOutput(output) {
    const results = {
      converged: false,
      finalEnergy: null,
      optimizedGeometry: null,
      cycles: null,
      maxGradient: null,
      rmsGradient: null
    };

    // Check convergence
    if (output.includes('THE OPTIMIZATION HAS CONVERGED')) {
      results.converged = true;
    }

    // Extract final energy
    const energyMatch = output.match(/FINAL SINGLE POINT ENERGY\s+(-?\d+\.\d+)/);
    if (energyMatch) {
      results.finalEnergy = parseFloat(energyMatch[1]);
    }

    // Extract optimization cycles
    const cycleMatch = output.match(/OPTIMIZATION RUN DONE AFTER\s+(\d+)\s+CYCLES/);
    if (cycleMatch) {
      results.cycles = parseInt(cycleMatch[1]);
    }

    // Extract final coordinates
    const coordMatch = output.match(/FINAL CARTESIAN COORDINATES[\s\S]*?-{20,}([\s\S]*?)-{20,}/);
    if (coordMatch) {
      results.optimizedGeometry = coordMatch[1].trim();
    }

    return results;
  }

  parseAbsorptionOutput(output) {
    const results = {
      excitationEnergies: [],
      oscillatorStrengths: [],
      absorptionSpectrum: null
    };

    // Parse TD-DFT results
    const tdSection = output.match(/TD-DFT EXCITED STATES[\s\S]*?(?=\n-{20,}|\nORCA TERMINATED)/);
    if (tdSection) {
      const stateMatches = tdSection[0].match(/STATE\s+(\d+):\s+E=\s+([\d.]+)\s+au\s+([\d.]+)\s+eV\s+f=([\d.]+)/g);
      
      if (stateMatches) {
        for (const match of stateMatches) {
          const parts = match.match(/STATE\s+(\d+):\s+E=\s+([\d.]+)\s+au\s+([\d.]+)\s+eV\s+f=([\d.]+)/);
          if (parts) {
            results.excitationEnergies.push({
              state: parseInt(parts[1]),
              energy_au: parseFloat(parts[2]),
              energy_eV: parseFloat(parts[3]),
              energy_nm: 1240 / parseFloat(parts[3]), // Convert eV to nm
              oscillatorStrength: parseFloat(parts[4])
            });
          }
        }
      }
    }

    // Parse spectrum data if available
    const spectrumMatch = output.match(/ABSORPTION SPECTRUM VIA TRANSITION ELECTRIC DIPOLE MOMENTS[\s\S]*?(?=\n-{20,}|\nORCA TERMINATED)/);
    if (spectrumMatch) {
      results.absorptionSpectrum = this.parseSpectrumData(spectrumMatch[0]);
    }

    return results;
  }

  parseFrequencyOutput(output) {
    const results = {
      frequencies: [],
      intensities: [],
      normalModes: [],
      thermochemistry: {},
      zeroPointEnergy: null
    };

    // Parse vibrational frequencies
    const freqSection = output.match(/VIBRATIONAL FREQUENCIES[\s\S]*?(?=\n-{20,}|\n[A-Z]{4,})/);
    if (freqSection) {
      const freqMatches = freqSection[0].match(/\d+:\s+([\d.-]+)\s+cm\*\*-1/g);
      if (freqMatches) {
        results.frequencies = freqMatches.map(match => {
          const freq = parseFloat(match.match(/([\d.-]+)/)[1]);
          return freq;
        });
      }
    }

    // Parse IR intensities
    const irSection = output.match(/IR SPECTRUM[\s\S]*?(?=\n-{20,}|\n[A-Z]{4,})/);
    if (irSection) {
      const intensityMatches = irSection[0].match(/\d+:\s+[\d.-]+\s+[\d.-]+\s+([\d.]+)/g);
      if (intensityMatches) {
        results.intensities = intensityMatches.map(match => 
          parseFloat(match.split(/\s+/).slice(-1)[0])
        );
      }
    }

    // Parse thermochemistry
    const thermoSection = output.match(/THERMOCHEMISTRY AT[\s\S]*?(?=\n-{20,}|\n[A-Z]{4,})/);
    if (thermoSection) {
      const tempMatch = thermoSection[0].match(/Temperature\s+\.\.\.\s+([\d.]+)\s+K/);
      const pressMatch = thermoSection[0].match(/Pressure\s+\.\.\.\s+([\d.]+)\s+atm/);
      const zpeMatch = thermoSection[0].match(/Zero point energy\s+\.\.\.\s+([\d.]+)\s+Eh/);
      const enthalpyMatch = thermoSection[0].match(/Total enthalpy\s+\.\.\.\s+([\d.-]+)\s+Eh/);
      const entropyMatch = thermoSection[0].match(/Total entropy correction\s+\.\.\.\s+([\d.-]+)\s+Eh/);

      if (tempMatch) results.thermochemistry.temperature = parseFloat(tempMatch[1]);
      if (pressMatch) results.thermochemistry.pressure = parseFloat(pressMatch[1]);
      if (zpeMatch) results.zeroPointEnergy = parseFloat(zpeMatch[1]);
      if (enthalpyMatch) results.thermochemistry.enthalpy = parseFloat(enthalpyMatch[1]);
      if (entropyMatch) results.thermochemistry.entropyCorrection = parseFloat(entropyMatch[1]);
    }

    return results;
  }

  parseSinglePointOutput(output) {
    const results = {
      energy: null,
      homoEnergy: null,
      lumoEnergy: null,
      homoLumoGap: null,
      dipoleMoment: null
    };

    // Extract total energy
    const energyMatch = output.match(/FINAL SINGLE POINT ENERGY\s+(-?\d+\.\d+)/);
    if (energyMatch) {
      results.energy = parseFloat(energyMatch[1]);
    }

    // Extract HOMO/LUMO energies
    const orbitalSection = output.match(/ORBITAL ENERGIES[\s\S]*?(?=\n-{20,}|\n[A-Z]{4,})/);
    if (orbitalSection) {
      const homoMatch = orbitalSection[0].match(/(\d+)\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)\s+1\.0000/);
      const lumoMatch = orbitalSection[0].match(/(\d+)\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)\s+0\.0000/);
      
      if (homoMatch) results.homoEnergy = parseFloat(homoMatch[3]); // eV
      if (lumoMatch) results.lumoEnergy = parseFloat(lumoMatch[3]); // eV
      
      if (results.homoEnergy !== null && results.lumoEnergy !== null) {
        results.homoLumoGap = results.lumoEnergy - results.homoEnergy;
      }
    }

    // Extract dipole moment
    const dipoleMatch = output.match(/Magnitude \(Debye\)\s*:\s*([\d.]+)/);
    if (dipoleMatch) {
      results.dipoleMoment = parseFloat(dipoleMatch[1]);
    }

    return results;
  }

  parseNMROutput(output) {
    const results = {
      chemicalShifts: [],
      shieldingConstants: [],
      couplingConstants: []
    };

    // Parse chemical shifts
    const nmrSection = output.match(/CHEMICAL SHIELDING SUMMARY[\s\S]*?(?=\n-{20,}|\n[A-Z]{4,})/);
    if (nmrSection) {
      const shiftMatches = nmrSection[0].match(/(\w+)\s*\(\s*(\d+)\s*\)\s*:\s*([\d.-]+)/g);
      if (shiftMatches) {
        for (const match of shiftMatches) {
          const parts = match.match(/(\w+)\s*\(\s*(\d+)\s*\)\s*:\s*([\d.-]+)/);
          if (parts) {
            results.chemicalShifts.push({
              atom: parts[1],
              atomNumber: parseInt(parts[2]),
              shift: parseFloat(parts[3])
            });
          }
        }
      }
    }

    return results;
  }

  parseReactionEnergyOutput(output) {
    const results = {
      energy: null,
      zeroPointEnergy: null,
      thermalCorrection: null,
      enthalpyCorrection: null,
      gibbsCorrection: null
    };

    // This is similar to single point but may include thermochemical corrections
    const energyMatch = output.match(/FINAL SINGLE POINT ENERGY\s+(-?\d+\.\d+)/);
    if (energyMatch) {
      results.energy = parseFloat(energyMatch[1]);
    }

    return results;
  }

  parseGenericOutput(output) {
    return {
      completed: output.includes('ORCA TERMINATED NORMALLY'),
      error: output.includes('ORCA finished by error termination'),
      rawOutput: output.substring(0, 1000) + (output.length > 1000 ? '...' : '')
    };
  }

  parseSpectrumData(spectrumSection) {
    const spectrum = [];
    const lines = spectrumSection.split('\n');
    
    for (const line of lines) {
      const match = line.match(/(\d+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)/);
      if (match) {
        spectrum.push({
          state: parseInt(match[1]),
          energy_eV: parseFloat(match[2]),
          wavelength_nm: parseFloat(match[3]),
          intensity: parseFloat(match[4])
        });
      }
    }
    
    return spectrum;
  }

  async validateInput(calculationType, inputData) {
    const errors = [];
    
    // Check if method is supported
    const supportedMethods = this.supportedMethods[calculationType];
    if (!supportedMethods || !supportedMethods.includes(inputData.method)) {
      errors.push(`Method ${inputData.method} not supported for ${calculationType} in ORCA`);
    }

    // Check molecule data
    if (!inputData.molecule || !inputData.molecule.atomsString) {
      errors.push('Molecule geometry is required');
    }

    // Check basis set format
    if (inputData.basisSet && !inputData.basisSet.match(/^[a-zA-Z0-9-*]+$/)) {
      errors.push('Invalid basis set format for ORCA');
    }

    return {
      valid: errors.length === 0,
      errors: errors
    };
  }

  getSupportedMethods(calculationType) {
    return this.supportedMethods[calculationType] || [];
  }

  getRecommendedSettings(calculationType, moleculeSize) {
    const recommendations = {
      'geometry_optimization': {
        small: { method: 'B3LYP', basisSet: 'def2-TZVP', memory: 4000 },
        medium: { method: 'B3LYP', basisSet: 'def2-SVP', memory: 8000 },
        large: { method: 'B3LYP', basisSet: 'def2-SVP', memory: 16000 }
      },
      'absorption_spectrum': {
        small: { method: 'CAM-B3LYP', basisSet: 'def2-TZVP', memory: 8000 },
        medium: { method: 'CAM-B3LYP', basisSet: 'def2-SVP', memory: 16000 },
        large: { method: 'B3LYP', basisSet: 'def2-SVP', memory: 32000 }
      },
      'frequency_analysis': {
        small: { method: 'B3LYP', basisSet: 'def2-TZVP', memory: 8000 },
        medium: { method: 'B3LYP', basisSet: 'def2-SVP', memory: 16000 },
        large: { method: 'B3LYP', basisSet: 'def2-SVP', memory: 32000 }
      }
    };

    const sizeCategory = moleculeSize < 15 ? 'small' : 
                        moleculeSize < 50 ? 'medium' : 'large';
    
    return recommendations[calculationType]?.[sizeCategory] || 
           recommendations['geometry_optimization']['medium'];
  }

  async cleanupFiles(keepResults = true) {
    // Clean up temporary files created by ORCA
    try {
      const files = await fs.readdir(this.workingDir);
      const tempFiles = files.filter(file => 
        file.endsWith('.tmp') || 
        file.endsWith('.gbw') || 
        file.endsWith('.prop') ||
        file.includes('orca_')
      );

      for (const file of tempFiles) {
        await fs.unlink(path.join(this.workingDir, file)).catch(() => {});
      }

      return { cleaned: tempFiles.length, kept: keepResults };
    } catch (error) {
      return { error: error.message };
    }
  }
}